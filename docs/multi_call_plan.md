# 多用户 / 多调用支持改造计划

本文档描述将当前「单会话独占」的 Chat 与后台任务，改造为可部署为**服务器**、支持**多重并发调用**的路线图。仅作计划，不包含具体实现细节。

---

## 一、目标与范围

- **目标**：支持多用户/多会话同时使用；**限流策略**为：全局「Research + Chat」活跃数不超过 2，其余请求排队并在前端**排队区**展示。
- **产品约定**：
  - **Chat**：同一 session 内允许多次输入（用户可连续发多条消息），不限制「每会话同时只能一个请求」——唯一限制是全局活跃槽位 ≤ 2。
  - **活跃**：指正在执行中的 Chat 流式请求或 Deep Research 任务；Ingest 可单独设上限，不占用这 2 个槽位（或按需纳入）。
- **范围**：后端统一活跃槽位与排队、前端多会话流式、排队区 UI、部署与可观测。

---

## 二、现状简要

| 模块 | 现状 | 多调用下的问题 |
|------|------|----------------|
| **Chat** | 请求内同步执行 `_run_chat()`，无队列 | 可并发（FastAPI 多请求），但前端全局 `isStreaming` 导致只能一个会话在「流式」 |
| **会话/记忆** | 按 `session_id` 存 DB，请求带 `optional_user_id` | 数据层面已支持多会话、多用户；同 session 并发写可能有竞态 |
| **Deep Research** | 队列 + 单进程内最多 2 个并发 | 多实例部署时每进程 2 个，无全局/每用户限流 |
| **Ingest** | 队列 + 单进程内最多 2 个并发 | 同上 |
| **前端** | 全局 `isStreaming`、单「当前会话」 | 无法在 A 会话流式时在 B 会话发消息或看到 B 的流式状态 |

---

## 三、后端改造计划

### 3.1 Chat 并发与隔离

- **产品**：同一 session 内允许多次输入；唯一限制是**全局 Research+Chat 活跃 ≤ 2**，超出则排队（见 3.2）。
- **保持**：Chat 仍在请求内执行、流式响应；进入执行前需先占「统一槽位」，占不到则进入统一排队。
- **保证**：
  - 同一 `session_id` 可能有多条请求在排队或先后执行，需保证 `add_turn` 等写入**顺序正确、不丢不重**（事务或按 session 串行写），见 3.4。
  - 不同 `session_id` 的请求已按 session 隔离；无全局可变状态被多请求共享。

### 3.2 限流与排队策略（核心）

- **全局活跃上限**：**Research + Chat 合计最多 2 个活跃**（即最多 2 个「槽位」同时执行）。
  - 占用槽位的：正在执行的 Chat 流式请求（`/chat/stream`）、正在执行的 Deep Research 任务。
  - Ingest 不占用这 2 个槽位，保持现有独立并发（如每进程 2 个）即可；若希望统一管控可后续纳入。
- **排队**：当活跃数已达 2 时，新发起的 Chat 或新提交的 Deep Research **进入排队**，不立即执行；待有槽位空出后按排队顺序依次执行。
- **实现要点**：
  - 后端维护「当前活跃数」与「排队队列」（进程内即可：信号量 + 队列结构，或统一任务队列）。
  - Chat：请求到达时若活跃 < 2 则占槽并执行，否则入队等待；流式结束或异常时释放槽位并拉取下一个排队项（若有）。
  - Deep Research：提交时若活跃 < 2 则占槽并入现有 DR 队列执行，否则先入「统一排队」再在有空槽时转入 DR 队列（或 DR 与 Chat 共用一个「通用槽位队列」）。
- **可配置**：活跃上限 2 可做成配置项（如 `max_concurrent_chat_and_research`），便于按机器规格调整。

### 3.3 后台任务（Deep Research / Ingest）与槽位

- **Deep Research**：与 Chat **共享**上述 2 个活跃槽位；DR 任务从「待执行」变为执行时占 1 槽，结束时释放 1 槽。现有 DR 队列（DB + task_runner）可保留，但领取执行前需先申请「统一槽位」，申请不到则本次不领取、等下一轮 poll 再试。
- **Ingest**：不占用 Research+Chat 的 2 槽，维持现有 2 并发（或单独配置），避免上传/解析拖垮对话与研报。
- **任务归属**：DB 中已有 `user_id` 的，用于「排队区按用户展示」和后续按用户限流（可选）。

### 3.4 会话与记忆的并发安全

- **SessionStore / Turn 写入**：同一 session 的多次 `add_turn` 并发时，需避免丢失更新或重复 turn_index。可选方案：
  - 在 session 维度加分布式锁或进程内锁后再写；或
  - 使用 DB 唯一约束/乐观锁（如 `turn_index` 由 DB 生成或版本号），失败重试或返回冲突。

---

## 四、前端改造计划

### 4.1 流式状态按会话（核心）

- **现状**：`useChatStore.isStreaming` 全局一个布尔，导致全应用只能一个请求在流式。
- **目标**：支持「会话 A 在流式时，会话 B 也能发起请求并独立流式」。
- **方案**：
  - 将 `isStreaming` 改为「按会话」的集合，例如 `streamingSessionIds: Set<string>`，或 `sessionId -> boolean`。
  - 发送消息时：`sessionId` 加入 `streamingSessionIds`；流结束/错误时从集合移除该 `sessionId`。
  - 输入框/发送按钮：仅当**当前会话**在 `streamingSessionIds` 中时才禁用（即 `streamingSessionIds.has(currentSessionId)`），其它会话不受影响。

### 4.2 多会话 UI 与数据

- **侧栏**：在会话列表中，对正在流式的会话显示「流式」指示（如小图标或 loading），数据来源即上面的 `streamingSessionIds`。
- **切换会话**：切换到会话 B 时，若 B 正在流式，应能展示 B 的流式内容（当前若只有「当前会话」的 messages 在更新，需确保流式更新的是「对应 session 的 messages」；若 store 仍是「单当前会话」模型，则需在切换时能恢复或订阅该会话的流式结果）。
- **多 Tab**：若未来支持多 Tab 各选不同会话，则每个 Tab 的「当前会话」不同，流式状态按会话即可自然支持（需注意同一会话不要在多个 Tab 同时发请求，可由前端约定或后端同 session 串行化保证）。

### 4.3 与 Deep Research 的协调

- **Deep Research** 与 Chat **共享 2 个活跃槽位**；DR 的「流式/进行中」占用 1 槽，与 chat 的 `streamingSessionIds` 一起受全局 2 槽限制。前端按会话/任务的「进行中」与「排队中」统一展示。

### 4.4 排队区

- **目标**：用户能看到「当前谁在跑、谁在排队」，避免误以为卡死。
- **内容**：
  - **活跃**：当前正在执行的 1～2 项（Chat 会话 + 会话摘要，或 Deep Research 任务 + 主题/进度）。
  - **排队**：等待中的项（Chat 按会话 + 最后一条消息摘要，DR 按任务 + 主题），并显示排队顺序（如「排队第 1 位」）。
- **位置**：可在侧栏顶部、或独立「任务/排队」面板、或顶部状态栏，与现有「后台任务」列表统一或合并。
- **交互**：排队中的 Chat 可考虑支持「取消排队」；DR 已有取消，排队中的 DR 也可取消并从排队移除。

---

## 五、阶段划分建议

| 阶段 | 内容 | 优先级 |
|------|------|--------|
| **Phase 1** | 后端：统一「Research + Chat」活跃槽位（上限 2）+ 排队队列；Chat 与 DR 执行前占槽、结束时释放并拉取排队。 | P0 |
| **Phase 2** | 前端：`isStreaming` 改为按会话；输入仅在当前会话占用槽位时禁用；侧栏显示「正在执行」的会话。 | P0 |
| **Phase 3** | 前端：**排队区** UI——展示当前活跃（≤2）与排队列表，支持取消排队（可选）。 | P0 |
| **Phase 4** | 后端：同 `session_id` 的 chat 并发安全或串行化（若同一会话可能连续发多条且都进队列）。 | P1 |
| **Phase 5** | 配置与可观测：`max_concurrent_chat_and_research` 可配置；指标（活跃数、排队深度）。 | P1 |
| **Phase 6** | 多 Tab / 多 worker 部署说明、Ingest 是否纳入统一限流（可选）。 | P2 |

---

## 六、风险与可选项

- **同 session 并发**：同一 session 内允许多次输入且可能同时有多条在排队；若两条先后开始执行，需保证 turn 写入顺序正确（后端串行化或乐观锁），见 Phase 4。
- **排队公平**：先到先服务即可；若需按用户公平（单用户不占满排队），可后续在队列层做 per-user 配额。
- **可选**：Chat 若保持「请求内流式」，排队需在网关/中间件层挂起请求直到有槽位；若改为「提交任务 + SSE 拉流」，排队更自然，但改动更大。

---

## 七、验收要点（简要）

- **限流**：同时活跃的 Research + Chat 不超过 2；第 3 个及以后进入排队，不直接 429（除非队列长度也设上限）。
- **排队区**：前端可见「当前 2 个活跃项」与「排队列表」，排队项有顺序或序号。
- **同一 session 多次输入**：同一会话可连续发多条；若都在排队，按顺序执行；执行中写入 turn 不丢、不乱序。
- **槽位释放**：Chat 流式结束或 DR 任务结束即释放槽位，排队中的下一项自动开始。

完成 Phase 1–3 即可满足「全局 2 槽 + 排队 + 排队区展示」；Phase 4–5 保证同会话并发安全与可配置/可观测。
